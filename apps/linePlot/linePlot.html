<script src="processing-1.4.1.js"></script>
<script type="text/processing" data-processing-target="mycanvas">

Neighborhood[] hoods;

int plotX1, plotX2, plotY1, plotY2; 

//String[] attributeNames; 

color backgroundColor = 0; 
float globalMaxValue;


void setup(){

 sageBeforeSetup();
 
  size(800, 800);
  
  plotX1 = (int)(width*.05);
  plotX2 = (int)(width*.95);
  plotY1 = (int)(height*.05);
  plotY2 = (int)(height*.95);
  
  filename = "fakeData.txt";
  readData(filename); 
  
  globalMaxValue = -99999999999.0; 
  
  sageAfterSetup();
}

void readData(String filename){
  //String filename = "fakeData.txt";
  
  String[] rows = loadStrings(filename);
  
  hoods = new Neighborhood[ rows.length-1] ;
  
  //rows[0] shows data labels
  //String[] titleTokens = split(rows[0], ",");
  //attributeNames = new String[ titleTokens.length ]; 
  //for(int i = 1; i < titleTokens.length; i++){
    //println("attr: " + attributeNames[i] );
   // attributeNames[i] = titleTokens[i] ;
  //}
  
  for(int i = 1; i < rows.length; i++){
     String[] tokens = split(rows[i], ","); 
     hoods[i-1] = new Neighborhood( tokens[0] ); 
     hoods[i-1].setNumValues( tokens.length-1 ); 
     for(int j = 1; j < tokens.length; j++){
       hoods[i-1].addValue(2000+j/12, parseFloat(tokens[j]) );
       if( parseFloat(tokens[j]) > globalMaxValue )
        globalMaxValue = parseFloat(tokens[j]);
     }
  }
  goRedraw = true;
}

void draw(){

    sageBeforeDraw();
  if( goRedraw ){ 
    
    background(backgroundColor); 
    
    stroke(255.0);
    strokeWeight(3);
    line(plotX1, plotY2, plotX2, plotY2);
    line(plotX1, plotY1, plotX1, plotY2);
    
    for(int i =0 ; i < hoods.length; i++){
      hoods[i].drawPlotLine();
    }
    
  }

      sageAfterDraw();
}


class Neighborhood{
  String name; 
  int[] years;
  float[] values; 
  int count;
  
  color theColor; 
  
  float minValue;
  float maxValue; 
  
  Neighborhood(String name){
    this.name = name;
    count = 0; 
    
    minValue = 99999999999.0;
    maxValue = -99999999999.0; 
    
    theColor = color( random(0, 255), random(0,255), random(0,255) );
  }
  
  void setNumValues(int num){
      years = new int[num];
      values = new float[num]; 

  }
  
  void addValue(int year, float value){
    years[count] = year;
    values[count] = value; 
    count++; 
    
      if( value < minValue ){
        minValue = value;  
      }
      if( value > maxValue){
         maxValue = value; 
      }
  }
  
  void drawPlotLine(){
    stroke(theColor); 
    beginShape();
    float gap = (mapYearToX(2001) - mapYearToX(2000))/2.0 ; 
    for(int i=0; i<values.length; i++){
      float x = mapYearToX( years[i] );
      float y = mapValueToY( values[i] );
      curveVertex(x, y );
      if( i == 0 || i == values.length-1)
              curveVertex(x, y );
//      if( mouseX-gap < x && mouseX+gap > x){
 //       fill(theColor);
  //      ellipse( x, y, 10, 10);
        
   //   }
        noFill();
    }
    endShape();
  }
  
//  void valueClosestToX(float x){
//      float gap = (mapYearToX(2001) - mapYearToX(2000));  ///2.0 ; 

 //   for(int i=0; i<values.length; i++){
  //    float x = mapYearToX( years[i] );
   //   if( mouseX-gap < x && mouseX+gap > x){
    //        return values[i] 
     // }
    //}
    //return -1;
 // }
}


float mapYearToX(float year){
  return map( year, 2000, 2013, plotX1, plotX2);
}

float mapValueToY(float value){
  return map( value, 0, globalMaxValue, plotY2, plotY1);
}



void mousePressed(){
    //your mouse pressed handler here
    
    //String toTransmit = ""; 
    
    //fill the pipe
    //for(int i = 0; i < hoods.length; i++){
    //    toTransmit += hoods.idx + ":" + hoods.valueClosestToX(mouseX) + " ";
    //}

    
    //sendMsg("PipeDataOut " + toTransmit );
    
}

void mouseDrag(){
    //your mouse drag handler here
}

void resizeSketch(int newWidth, int newHeight){
    size( newWidth, newHeight ); 
    
  plotX1 = (int)(newWidth*.05);
  plotX2 = (int)(newWidth*.95);
  plotY1 = (int)(newHeight*.05);
  plotY2 = (int)(newHeight*.95);
}
    

void acceptSelectionEvents( String selectedId ){


}


//let sage know that an item has been selected 
void emitSelectionEvents( String selectedId ){
    
    
}

//------------------------------------------------------------------------

void sageBeforeSetup(){

}

void sageAfterSetup(){
    goRedraw = true;
}

void sageBeforeDraw(){
    if( readyLoadData ){
        readData(filename);
        readyLoadData = false;
        goRedraw = true;
    }
    if( setMouseToPointer ){
        mouseX = pointerX;
        mouseY = pointerY;
        setMouseToPointer = false;

    }
    if( handlePointerPress ){
        //assume mouse already set to pointer, bc of flag... 
        mousePressed(); //call yourself
        
        //for debugging:
        sendMsg("pointer event at x= " + mouseX + " y= " + mouseY); 
        
        handlePointerPress = false; 
    }
    if( handleResize ){
        resizeSketch( newWidth, newHeight );
        handleResize = false; 
    }
    if( goSyncColor ){
        for(int i = 1; i < colorSyncTokens.length; i+=4){
            var id = parseInt(colorSyncTokens[i]);
            var r = parseInt(colorSyncTokens[i+1]);
            var g = parseInt(colorSyncTokens[i+2]);
            var b = parseInt(colorSyncTokens[i+3] );
            //console.log( id + " " + r + " " + g + " " + b )
            for(int j = 0 ; j < hoods.length; j++){
               if( parseInt( hoods[j].name ) == id ){
                    hoods[j].theColor = color(r, g, b );
                    break;
                }
            }
        }

        goRedraw = true;
    }
}


void sageAfterDraw(){
    //sendMsg( "drawDone");   
    goRedraw = false; 
}

</script>
<canvas id="mycanvas"></canvas>
<script type="text/javascript" src="../../lib/socket.io.min.js"></script>
<script type="application/javascript">
var url;
var socket;

url = window.location.origin;  //works on desktop and thor
if( url.indexOf("iridium") >= 0 ) //iridium is special
    url = "10.0.8.100:9090";
socket = io.connect(url);
console.log("Connected to server: ", url);

//--------- LISTEN TO EVENTS FROM WEBSAGE---------------
//to do:  make this array of pointer objects... 
var pointerX = 0;
var pointerY = 0; 
var handlePointerPress = false; 
var pointerPressed = false; 
var goRedraw = false; 
var handleResize = false;
var newWidth = 0;
var newHeight =0;
var setMouseToPointer = false; 
var readyLoadData = false; 
var filename = "";
var itemId = "";
var readyAddTags = false;
var theNewTags = [];
var newRed = 0;
var newBlue = 0;
var newGreen = 0;
var colorSyncId = 0;
var goSyncColor = false;

var colorSyncTokens = [];


window.addEventListener("message", receiveMessage, false);
function receiveMessage(event)
{
//   if (event.origin !== "http://example.org:8080")  //may add this later for security concerns
//     return;

//     if( event.data.indexOf('dataSend') != -1 ){
//         var tokens = event.data.split(' ');
//         inputData = tokens[1] ;
//     }
    if( event.data.indexOf( 'pointerCreated') != -1 ){
        //create pointer object
    }
    if (event.data.indexOf( 'pointerClick') != -1) {
        var tokens = event.data.split(' ');
        pointerX = tokens[2];
        pointerY = tokens[4]; 
        pointerPressed = true; 
        handlePointerPress = true;     
        goRedraw = true;   
        setMouseToPointer = true;
    }
    else if (event.data.indexOf( 'pointerMove') != -1) {
        var tokens = event.data.split(' ');
        pointerX = tokens[2];
        pointerY = tokens[4]; 
        goRedraw = true;     
        setMouseToPointer = true;
        if( pointerPressed ){
            //pointer drag
        }
    } 
    else if( event.data.indexOf( 'pointerReleased') != -1 ){
        pointerPressed = false; 
    }
    else if( event.data.indexOf( 'pointerScrolled' ) != -1){
        //handle scroll events
    }
    else if(event.data.indexOf('resize') != -1){
        var tokens = event.data.split(' ' ); 
        newWidth = tokens[2];
        newHeight = tokens[4]; 
        goRedraw = true;
        handleResize = true; 
    }
    else if( event.data.indexOf("loadData") != -1 ){
        var tokens = event.data.split(' ' ); 
        filename = tokens[2];
        readyLoadData = true;
        itemId = tokens[4];
    }
    else if( event.data.indexOf("setItemId") != -1){
        var tokens = event.data.split(' ' ); 
        itemId = tokens[2];
    }
    else if (event.data.indexOf("color") != -1 ){
         colorSyncTokens = event.data.split(' ' );
         console.log("sync!  " + event.data);
//         for(int i = 0; i < tokens.size; i++){
//             
//         }
//         newRed = parseInt(tokens[2]);
//         newGreen = parseInt(tokens[3]);
//         newBlue = parseInt(tokens[4]);
//         colorSyncId = parseInt(tokens[1]); 
//         
//         console.log("color sync id = " + colorSyncId);
        goSyncColor = true;
    }
    
    
//     else if( event.data.indexOf("metaAdded") != -1 ){
// //         theNewTags = []; 
// //         readyAddTags = true;
// //         var tokens = event.data.split(' ');
// //         for(var i = 1; i < tokens.length; i++){
// //             theNewTags[i-1] = tokens[i];
// //         }
//         statusText = "ADDED!!";//event.data;
//         goRedraw = true;
//     }

}


//--------- SEND EVENTS TO WEBSAGE ---------------
function sendMsg(msg){
    
    socket.emit("eventInWindowRecorded", (msg+" id " + itemId) );
    
    //window.parent.postMessage('sendingMsg: ' + msg, '*');  
//     
//         pointerX = 800;
//         pointerY = 100; 
//         pointerPressed = true;     
//         readyRedraw = true;  
}


</script>